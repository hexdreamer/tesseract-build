#! /bin/zsh

readonly _PROGNAME=$0:A
readonly _SCRIPTSDIR=${_PROGNAME%/precommit}

checkFile() {
  local fname=$1
  local tmpfile=

  tmpfile=.precommit-tmp-file

  # :0:FNAME means 'stage 0 entry', or just "staged"
  git cat-file -p :0:"$fname" > $tmpfile

  shebang=$(head -n1 "$tmpfile")
  if [[ $shebang != */bin/zsh* ]]; then
    echo "ERROR $fname: wanted shebang == */bin/zsh*, got '$shebang'"
  fi

  # Even though using Bash rules, Zsh is similar enough.
  # Any Zsh-specific irregularities will have accompanying
  # `shellcheck disable` statements inline, or in the .shellcheckrc file
  shellcheck -f gcc -s bash "$tmpfile" | awk '{print "ERROR " $0; }'

  # Format scripts for whitespace and indents
  # shFmt -i 2 -ci -w "$fname"

  rm "$tmpfile"
}

print_errors() {
  echo
  echo "- precommit errors with $fname"
  for i in "$@"; do
    echo "  - $i"
  done
}

main() {
  local fname=

  if git rev-parse --verify HEAD >/dev/null 2>&1; then
    against=HEAD
  else
    # Initial commit: diff against an empty tree object
    against=$(git hash-object -t tree /dev/null)
  fi

  # Redirect output to stderr.
  exec 1>&2

  local errs=
  for fname in $(git diff --cached --name-only "$against");
    do
    for i in Scripts/build.sh Scripts/test.sh Scripts/precommit;
      do
      if [ "$fname" = "$i" ]; then
        local _errs=
        _errs=$(checkFile "$fname")
        if [ "$_errs" != "" ]; then
          local msg=
          msg=$(print_errors "$_errs")
          if [ "$errs" = "" ]; then
            errs="$msg"
          else
            errs="$errs\n$msg"
          fi
        fi
      fi
    done
  done

  _errs=$(${_SCRIPTSDIR}/run_tests.sh)
  _status=$?
  if [ $_status -ne 0 ]; then
    local msg=
    msg=$(print_errors "$_errs")
    if [ "$errs" = "" ]; then
      errs="$msg"
    else
      errs="$errs\n$msg"
    fi
  fi

  if [ "$errs" != "" ]; then
    echo "$errs"
    echo
    exit 1
  fi


}

main
